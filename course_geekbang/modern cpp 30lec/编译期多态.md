## 解决的问题
多态分为编译期多态和运行期多态，即静态多态和动态多态。动态多态由接口和继承链的virtual函数实现，解决在具体实现时选择差异化的通用行为的问题。而静态多态依托泛型实现，解决**代码复用问题**。

**如果一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那么这只鸟就可以被当作鸭子。**

鸭子类型使得开发者可以不使用继承体系来灵活地实现一些“约定”，尤其是使得混合不同来源、使用不同对象继承体系的代码成为可能。唯一的要求只是，这些不同的对象有“共通”的成员函数。这些成员函数应当有相同的名字和相同结构的参数（并不要求参数类型相同）。

在C++中实现鸭子类型可以通过模板或者说泛型编程。不管是类模板还是函数模板，编译器在看到其定义时只能做最基本的语法检查，真正的类型检查要在实例化（instantiation）的时候才能做。一般而言，这也是编译器会报错的时候。

## 特化模板

需要使用的模板参数类型，不能完全满足模板的要求，比如缺省某些运算符。此时可以：

- 添加代码，让那个类型支持所需要的操作（对成员函数无效）。
- 对于函数模板，可以直接针对那个类型进行重载。
- 对于类模板和函数模板，可以针对那个类型进行特化。

特化又可分为**全特化**和**偏特化**：

- 全特化：对所有模板参数进行特化
- 偏特化：局部的参数特化或者**类模板的重载**

**注意：函数模板不存在偏特化，只有重载。**

例如：

对于函数模板
```c++
template<typename T>
bool isEqual(T t1, T t2) {
    cout << "函数模板" << endl;
    return t1 == t2;
}
```
char类型无法使用，因为“==”运算符是对char型首地址的比较。可通过全特化或重载解决。
